# 検索アルゴリズムとスコアリング方針

## スコアリング戦略 (Ranking Strategy)

ユーザー体験を最大化するため、単一の指標ではなく、複数の要素を組み合わせた**複合スコア (Composite Score)** を採用します。

### 推奨アルゴリズム (Hybrid Scoring)

最終的な `matchScore` は、以下の要素の加重平均（または加算）で算出します。

$$
Score = (Vector \times W_v) + (Keyword \times W_k) + (Popularity \times W_p)
$$

| 要素                   | 役割             | 理由                                                                           |
| :--------------------- | :--------------- | :----------------------------------------------------------------------------- |
| **Vector Similarity**  | 意味的適合度     | ユーザーの「意図」を汲み取る。表記ゆれや類義語に対応。                         |
| **Keyword Match**      | 完全一致ボーナス | ユーザーが「特定の単語」を入力した場合、それが含まれる記事を確実に上位にする。 |
| **Popularity / Decay** | 品質・鮮度       | 「有名な曲」「新しい記事」など、一般的に需要が高いものを底上げする。           |

### フェーズ別実装計画

#### Phase 1: シンプルなハイブリッド (MVP)

まずはベクトル検索とキーワード検索の実装を優先します。

- **計算式:** `matchScore = (VectorScore * 0.7) + (KeywordScore * 0.3)`
- **狙い:** まずは「探してるものが出る」状態を作る。

#### Phase 2: ビジネスロジックの注入

データが蓄積されてきたら、閲覧数などの係数を導入します。

- **計算式:** `BaseScore = (Vector + Keyword) ... FinalScore = BaseScore * log(ViewCount)`
- **狙い:** 「人気のある良質な記事」を優先表示する。

## DTOとの関係

APIのレスポンス（`ArticleSearchResultItemDto`）に含まれる `matchScore` は、この**計算後の最終スコア**です。
したがって、API利用側（フロントエンド）は単純に `matchScore` の降順で表示すれば良く、計算ロジックを知る必要はありません。
